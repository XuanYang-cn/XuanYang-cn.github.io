<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Posts on Hello Friend</title>
        <link>https://xuanyang-cn.github.io/posts/</link>
        <description>Recent content in Posts on Hello Friend</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <copyright>&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CC BY-NC 4.0&lt;/a&gt;</copyright>
        <lastBuildDate>Fri, 26 Mar 2021 14:52:08 +0800</lastBuildDate>
        <atom:link href="https://xuanyang-cn.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
        
        <item>
            <title>Go pprof Ref</title>
            <link>https://xuanyang-cn.github.io/posts/2021/03/go-pprof-ref/</link>
            <pubDate>Fri, 26 Mar 2021 14:52:08 +0800</pubDate>
            
            <guid>https://xuanyang-cn.github.io/posts/2021/03/go-pprof-ref/</guid>
            <description>GCTRACE  gctrace: setting gctrace=1 causes the garbage collector to emit a single line to standard error at each collection, summarizing the amount of memory collected and the length of the pause. The format of this line is subject to change. Currently, it is:
  gc # @#s #%: #+#+# ms clock, #+#/#/#+# ms cpu, #-&amp;gt;#-&amp;gt;# MB, # MB goal, # P where the fields are as follows:
 gc # the GC number, incremented at each GC @#s time in seconds since program start #% percentage of time spent in GC since program start #+.</description>
            <content type="html"><![CDATA[<h2 id="gctrace">GCTRACE</h2>
<blockquote>
<p>gctrace: setting gctrace=1 causes the garbage collector to emit a single line to standard
error at each collection, summarizing the amount of memory collected and the
length of the pause. The format of this line is subject to change.
Currently, it is:</p>
</blockquote>
<pre><code>    gc # @#s #%: #+#+# ms clock, #+#/#/#+# ms cpu, #-&gt;#-&gt;# MB, # MB goal, # P
</code></pre><p>where the fields are as follows:</p>
<pre><code>    gc #        the GC number, incremented at each GC
    @#s         time in seconds since program start
    #%          percentage of time spent in GC since program start
    #+...+#     wall-clock/CPU times for the phases of the GC
    #-&gt;#-&gt;# MB  heap size at GC start, at GC end, and live heap
    # MB goal   goal heap size
    # P         number of processors used
</code></pre><p>Change environment variable <code>GODEBUG='gctrace=1'</code>, then Go will output gc log to stdout.</p>
<pre><code>gc 21 @8.223s 0% 0.032+3.0+0.12ms clock, 1.6+2.8/14/10+4.0 ms cpu, 87-&gt;88-&gt;45 MB, 89 MB goal, 24 P
</code></pre><h2 id="pprof-listen-to-a-port">pprof listen to a port</h2>
<p>Add these lines in program.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">import</span> (
    <span style="color:#e6db74">&#34;fmt&#34;</span>
    <span style="color:#a6e22e">_</span> <span style="color:#e6db74">&#34;net/http/pprof&#34;</span>
    <span style="color:#e6db74">&#34;net/http&#34;</span>
)

<span style="color:#66d9ef">go</span> <span style="color:#66d9ef">func</span>(){
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">http</span>.<span style="color:#a6e22e">ListenAndServe</span>(<span style="color:#e6db74">&#34;localhost:9876&#34;</span>, <span style="color:#66d9ef">nil</span>))
}()
</code></pre></div><p>Open <code>http://127.0.0.1:9876/debug/pprof</code> in web browser.</p>
<h2 id="exam-pprof-in-web-browser">Exam pprof in web browser</h2>
<p>Mostly, we are concerned about <code>goroutine</code> and <code>heap</code> and cpu <code>profile</code>.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">$ curl -s http://127.0.0.1:9876/debug/pprof/heap &gt; first.heap

<span style="color:#75715e"># sometime later</span>
$ curl -s http://127.0.0.1:9876/debug/pprof/heap &gt; second.heap
</code></pre></div><p>we can compare them by</p>
<pre><code>go tool pprof -base first.heap second.heap
</code></pre><p>We can also look at a 30-second CPU profile</p>
<pre><code>go tool pprof http://127.0.0.1:9876/debug/pprof/profile?seconds=30
</code></pre><p><strong>reference</strong></p>
<pre><code>[1] [The Go Blog: Profiling Go Programs](https://blog.golang.org/pprof)
[2] [Go http pprof doc](https://golang.org/pkg/net/http/pprof/)
</code></pre>
]]></content>
        </item>
        
        <item>
            <title>Cgo: All You Need to Know</title>
            <link>https://xuanyang-cn.github.io/posts/2021/02/cgo-all-you-need-to-know/</link>
            <pubDate>Tue, 23 Feb 2021 16:05:20 +0800</pubDate>
            
            <guid>https://xuanyang-cn.github.io/posts/2021/02/cgo-all-you-need-to-know/</guid>
            <description>Cgo Intro Cgo 让 GO 可以调用 C 的代码。
接下来就用一个简单的例子来介绍 Cgo 的用法。
下面 GO 的 rand 包提供了两个方法 Random 和 Seed， 它们分别调用了 C 的 random 和 srandom 方法。
package rand /* #include &amp;lt;stdlib.h&amp;gt; */ import &amp;#34;C&amp;#34; func Random() int { return int(C.random()) } func Seed(i int) { C.srandom(C.uint(i)) } // ref@https://blog.golang.org/cgo 从 import 语句来看，rand 包引入了 &amp;quot;C&amp;quot;， 但是你会发现标准 Go library 里并没有 C 这个库。这是因为 C 是一个伪包 (pesudo-package)，是一个可以被 cgo 解析的特殊名字，用来确定代码里 C 的命名空间。
rand 包用到 C 的地方有 4 个：C.</description>
            <content type="html"><![CDATA[<h2 id="cgo-intro">Cgo Intro</h2>
<p>Cgo 让 GO 可以调用 C 的代码。</p>
<p>接下来就用一个简单的例子来介绍 Cgo 的用法。</p>
<p>下面 GO 的 <code>rand</code> 包提供了两个方法 <code>Random</code> 和 <code>Seed</code>， 它们分别调用了 C 的 <code>random</code> 和 <code>srandom</code> 方法。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">rand</span>

<span style="color:#75715e">/*
</span><span style="color:#75715e">#include &lt;stdlib.h&gt;
</span><span style="color:#75715e">*/</span>
<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;C&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Random</span>() <span style="color:#66d9ef">int</span> {
    <span style="color:#66d9ef">return</span> int(<span style="color:#a6e22e">C</span>.<span style="color:#a6e22e">random</span>())
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Seed</span>(<span style="color:#a6e22e">i</span> <span style="color:#66d9ef">int</span>) {
    <span style="color:#a6e22e">C</span>.<span style="color:#a6e22e">srandom</span>(<span style="color:#a6e22e">C</span>.uint(<span style="color:#a6e22e">i</span>))
}
<span style="color:#75715e">// ref@https://blog.golang.org/cgo
</span></code></pre></div><p>从 <code>import</code> 语句来看，<code>rand</code> 包引入了 <code>&quot;C&quot;</code>， 但是你会发现标准 Go library 里并没有 <code>C</code> 这个库。这是因为 <code>C</code> 是一个伪包 (pesudo-package)，是一个可以被 cgo 解析的特殊名字，用来确定代码里 C 的命名空间。</p>
<p><code>rand</code> 包用到 <code>C</code> 的地方有 4 个：<code>C.random</code>， <code>C.srandom</code>， <code>C.uint(i)</code> 以及 <code>import &quot;C&quot;</code>。</p>
<p>其中，<code>Random()</code> 方法调用了 C 语言标准库的 <code>random()</code> 方法并返回了其返回值。在 C 语言中， <code>random()</code> 方法的返回值是 C 语言的 <code>long</code> （cgo 使用 <code>C.long</code> 来表示）类型，必须将它转换为 Go 语言的类型才能让包外的 Go 代码使用， 普通的 Go 类型转换即可：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Random</span>() <span style="color:#66d9ef">int</span> {
  <span style="color:#66d9ef">return</span> int(<span style="color:#a6e22e">C</span>.<span style="color:#a6e22e">random</span>())
}
</code></pre></div><p>一个功能相同但是能更清晰展示类型转换过程的代码如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Random</span>() <span style="color:#66d9ef">int</span> {
  <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">r</span> <span style="color:#a6e22e">C</span>.<span style="color:#a6e22e">long</span> = <span style="color:#a6e22e">C</span>.<span style="color:#a6e22e">random</span>()
  <span style="color:#66d9ef">return</span> int(<span style="color:#a6e22e">r</span>)
}
</code></pre></div><p><code>Seed()</code> 方法则展示了相反的类型转换过程。它的输入是 Go 的 <code>int</code> 类型，需要转换成 C 的<code>unsigned int</code> （Cgo 通过 <code>C.uint</code> 来表示）类型，作为 C 的 <code>srandom()</code> 方法的参数传入。</p>
<p>// TODO complete list of these numeric type names.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Seed</span>(<span style="color:#a6e22e">i</span> <span style="color:#66d9ef">int</span>) {
  <span style="color:#a6e22e">C</span>.<span style="color:#a6e22e">srandom</span>(<span style="color:#a6e22e">C</span>.uint(<span style="color:#a6e22e">i</span>))
}
</code></pre></div><p>这段代码里还有一部分代码我们还没解释，那就是 <code>import</code> 语句上面的注释。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#75715e">/*
</span><span style="color:#75715e">#include &lt;stdlib.h&gt;
</span><span style="color:#75715e">*/</span>
<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;C&#34;</span>
</code></pre></div><p>Cgo 会读取这段注释：</p>
<ul>
<li>以 <code>#cgo</code> + 空格开头的一行注释，Cgo 会删掉 <code>#cgo</code> 和空格，剩下的作为 Cgo 的配置保留。</li>
<li>剩下的注释行会被当作编译 C 代码时的 header 来使用。</li>
</ul>
<p>在这个例子中，只有 <code>#include</code> 这一行会被识别。<code>#Cgo</code> 后面的代码一般用来给 C 代码的编译器和链接器提供 flags。</p>
<h3 id="strings">Strings</h3>
<p>和 Go 不同的是，C 的 String 是通过 <code>\0</code> 结尾的 char 数组来构成的。Go 和 C 的 String 类型互相转换是由 <code>C.CString()</code>，<code>C.GoString()</code> 和 <code>C.GoStringN()</code> 这几个方法来实现的，转换过程会拷贝 String 数据。</p>
<p>下面这个例子的 <code>Print()</code> 方法调用了 C 的<code>stdio.h</code> 库里的 <code>fputs()</code> 来向标准输出写一个 String。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">print</span>

<span style="color:#75715e">// #include &lt;stdio.h&gt;
</span><span style="color:#75715e">// #include &lt;stdlib.h&gt;
</span><span style="color:#75715e"></span><span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;C&#34;</span>
<span style="color:#f92672">import</span> <span style="color:#a6e22e">unsafe</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Print</span>(<span style="color:#a6e22e">s</span> <span style="color:#66d9ef">string</span>) {
  <span style="color:#a6e22e">cs</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">C</span>.<span style="color:#a6e22e">CString</span>(<span style="color:#a6e22e">s</span>)
  <span style="color:#a6e22e">C</span>.<span style="color:#a6e22e">fputs</span>(<span style="color:#a6e22e">cs</span>, (<span style="color:#f92672">*</span><span style="color:#a6e22e">C</span>.<span style="color:#a6e22e">FILE</span>)(<span style="color:#a6e22e">C</span>.<span style="color:#a6e22e">stdout</span>))
  <span style="color:#a6e22e">C</span>.<span style="color:#a6e22e">free</span>(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#a6e22e">cs</span>))
}
</code></pre></div><p>Go 的内存管理器无法管理 C 分配的内存，因此当你用 <code>C.CString()</code> 来创建一个 C 的 String （或任何其他 C 的内存分配）时，你必须手动调用 <code>C.free()</code> 来释放这部分的内存。</p>
<p>调用 <code>C.CString()</code> 会返回一个指向 char 数组首地址的指针，所以在函数退出之前我们需要将它转换为 <code>unsafe.Pointer</code> 并且使用 <code>C.free()</code> 释放掉这部分内存。Cgo 的最佳实现中一般会在分配内存的地方立刻使用 <code>defer()</code> 来释放内存，如下面更新的代码：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Print</span>(<span style="color:#a6e22e">s</span> <span style="color:#66d9ef">string</span>) {
  <span style="color:#a6e22e">cs</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">C</span>.<span style="color:#a6e22e">CString</span>(<span style="color:#a6e22e">s</span>)
  <span style="color:#66d9ef">defer</span>(<span style="color:#a6e22e">C</span>.<span style="color:#a6e22e">free</span>(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#a6e22e">cs</span>)))
  <span style="color:#a6e22e">C</span>.<span style="color:#a6e22e">fputs</span>(<span style="color:#a6e22e">cs</span>, (<span style="color:#f92672">*</span><span style="color:#a6e22e">C</span>.<span style="color:#a6e22e">FILE</span>)(<span style="color:#a6e22e">C</span>.<span style="color:#a6e22e">stdout</span>))
}
</code></pre></div><h3 id="build-cgo-packages">Build Cgo packages</h3>
<p>使用 <code>go build</code> 或 <code>go install</code> 就可以编译 Cgo 代码。当 Go 识别出引用了特殊的 <code>&quot;C&quot;</code> 时， 会自动使用 Cgo 来处理这些文件。</p>
<h3 id="总结">总结</h3>
<p>现在我们已经知道了一个正确的 Cgo 代码应该如何组织，Go 如何表示 C 的各种类型、方法，C 和 Go 的 String 类型如何互换，如何编译 Cgo 代码。</p>
<p>这自然而然的引出了下面的几个问题：</p>
<ol>
<li>C 能调用 GO 的方法吗？</li>
<li>C 和 Go 如何传递指针？</li>
<li>我有一个纯 C 的大型项目，可以编译成为静态/动态库，那么我的 Go 如何使用 Cgo 调用这些库？</li>
<li>我没有 C 的项目，但是我有一个 C++ 的项目，那么我的 GO 项目能否/如何使用 Cgo 来调用这个 C++ 的库？</li>
<li>Cgo 编译和链接的原理是什么？它是实现了一套 c 的编译器链接器还是直接使用的 gcc ？</li>
</ol>
<p>我在这里挖个坑，请期待接下来的本文的更新吧！</p>
<h2 id="cgo-advanced">Cgo Advanced</h2>
<h3 id="go-references-to-c">Go references to C</h3>
<h3 id="c-references-to-go">C references to Go</h3>
<h3 id="passing-pointers">Passing pointers</h3>
<h3 id="others">Others</h3>
<h2 id="cpp-yes">CPP? Yes!</h2>
<h2 id="cgo-implementation-details">Cgo Implementation details</h2>
<h2 id="references">References</h2>
<p>[1] <a href="https://blog.golang.org/cgo">https://blog.golang.org/cgo</a>. <em>C? Go? Cgo!</em> Andrew Gerrand. 17 March 2017.</p>
<p>[2] <a href="https://golang.org/cmd/cgo/">https://golang.org/cmd/cgo/</a>. Cgo official doc. Go 1.16.</p>
]]></content>
        </item>
        
        <item>
            <title>Delve Hand Book</title>
            <link>https://xuanyang-cn.github.io/posts/2021/02/delve-hand-book/</link>
            <pubDate>Thu, 18 Feb 2021 15:34:42 +0800</pubDate>
            
            <guid>https://xuanyang-cn.github.io/posts/2021/02/delve-hand-book/</guid>
            <description>Launch a session dlv debug works like go run, it will build an run a GO package
dlv exec will start a seesion with a precompiled binary, in order to properly debug a binary, it shoud be compiled with optimizations disablesd, eg. with -gcflags=&amp;quot;all=-N -l&amp;quot;
dlv attach will attach to a PID of a runnig Go binary
Delve commands in a debugging session print, p
whatis will print the datatype of an expression</description>
            <content type="html"><![CDATA[<h2 id="launch-a-session">Launch a session</h2>
<p><strong><code>dlv debug</code></strong> works like <code>go run</code>, it will build an run a GO package</p>
<p><strong><code>dlv exec</code></strong> will start a seesion with a precompiled binary, in order to properly debug a binary,
it shoud be compiled with optimizations disablesd, eg. with <code>-gcflags=&quot;all=-N -l&quot;</code></p>
<p><strong><code>dlv attach</code></strong> will attach to a PID of a runnig Go binary</p>
<h2 id="delve-commands-in-a-debugging-session">Delve commands in a debugging session</h2>
<p><strong><code>print, p</code></strong></p>
<p><strong><code>whatis</code></strong> will print the datatype of an expression</p>
<p><strong><code>locals</code></strong> will print all variables in the current execution step</p>
<p><strong><code>args</code></strong> will print the current fucntion&rsquo;s arguments</p>
<p><strong><code>vars</code></strong> will print the avaliable package variables</p>
<p><strong><code>funcs</code></strong> will print the avaliable functions</p>
<p><strong><code>types</code></strong> will print the avaliable types</p>
<p><strong><code>list</code></strong> display the code around the current execution step or a specific linespec.</p>
<h2 id="breakpoints">Breakpoints</h2>
<p><strong><code>break, b</code></strong>:</p>
<ul>
<li>Break at a specific line, sucn as <code>break main.go:15</code></li>
<li>Break at a relative point int a file <code>break +5</code></li>
<li>Whenever a function is called or defined, as <code>break main.myfunc</code></li>
</ul>
<p><strong><code>breakpoints, bp</code></strong>: display all breakpoints along with their IDs.</p>
<p><strong><code>condition, cond</code></strong>: set smarter stop conditions and not halt execution in a specific line, but whenever a
given condition is met.</p>
<p><strong><code>clear</code></strong> and <strong><code>clear all</code></strong> can be used to clear a specific or all breakpoints.</p>
<p><strong><code>trace</code></strong>: a breakpoint that doesn&rsquo;t halt execution, but print message whenever eht execution passes
through that point</p>
<h2 id="move-one-step-at-a-time">Move one step at a time!</h2>
<p><strong><code>continue, c</code></strong> runs until the next breakpoint or program termination</p>
<p><strong><code>next, n</code></strong> N steps over N source lines, staying int the same function</p>
<p><strong><code>step, s</code></strong> performs a single step forward in the application. If the next step is another fucntion,
it will descent to its call.</p>
<p><strong><code>stepout, so</code></strong> steps out of the current function</p>
<p><strong><code>restart</code></strong> restart the debugging session, but keeps breakpoints and conditions</p>
]]></content>
        </item>
        
        <item>
            <title>My First Post</title>
            <link>https://xuanyang-cn.github.io/posts/2021/01/my-first-post/</link>
            <pubDate>Mon, 18 Jan 2021 14:32:11 +0800</pubDate>
            
            <guid>https://xuanyang-cn.github.io/posts/2021/01/my-first-post/</guid>
            <description></description>
            <content type="html"><![CDATA[]]></content>
        </item>
        
    </channel>
</rss>
