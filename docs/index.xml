<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Hello Friend</title>
    <link>https://xuanyang-cn.github.io/</link>
    <description>Recent content on Hello Friend</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CC BY-NC 4.0&lt;/a&gt;</copyright>
    <lastBuildDate>Mon, 06 Mar 2023 17:46:41 +0800</lastBuildDate><atom:link href="https://xuanyang-cn.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Hybrid Search of Pinecone</title>
      <link>https://xuanyang-cn.github.io/posts/2023/03/hybrid-search-of-pinecone/</link>
      <pubDate>Mon, 06 Mar 2023 17:46:41 +0800</pubDate>
      
      <guid>https://xuanyang-cn.github.io/posts/2023/03/hybrid-search-of-pinecone/</guid>
      <description>1. Brief A summery of paper An analysis of Fusion Functions for Hybrid Retrieval and the following three articles.
[1]. Introducing support for sparse-dense embeddings for better search results
[2]. Sparse-dense embeddings, keyword-aware semantic search, Concepts
[3]. Ecommerce Hybrid Search, Hybrid Search Case
[4]. Tao Chen, Mingyang Zhang, Jing Lu, Michael Bendersky, and Marc Najork. 2022. Out-of-Domain Semantics to the Rescue! Zero-Shot Hybrid Retrieval Models. In Advances in Information Retrieval: 44th European Conference on IR Research, ECIR 2022, Stavanger, Norway, April 10-14, 2022, Proceedings, Part I (Stavanger, Norway).</description>
    </item>
    
    <item>
      <title>How To Build Develop Environment with Vim</title>
      <link>https://xuanyang-cn.github.io/posts/2022/11/how-to-build-develop-environment-with-vim/</link>
      <pubDate>Tue, 22 Nov 2022 18:30:27 +0800</pubDate>
      
      <guid>https://xuanyang-cn.github.io/posts/2022/11/how-to-build-develop-environment-with-vim/</guid>
      <description>This article helps myself to quickly establish a workable environments in Ubuntu with vim for
 The following languages: Golang, Python, CPP, MarkDown. Auto completion, jump to definition, rename variables, jump to files, jump to greps, auto lint Shell tools: git, rg, hugo, etc.  Just use docker  Download docker Use Dockerfile  I have a really Ubuntu 1. Install essentials Maybe important $ sudp apt update &amp;amp;&amp;amp; apt install wget curl ca-certificates build-essential gnupg2 lcov libtool m4 autoconf automake libssl-dev zlib1g-dev libboost-all-dev libboost-program-options-dev libboost-system-dev libboost-filesystem-dev libboost-serialization-dev libboost-python-dev libboost-regex-dev libcurl4-openssl-dev libtbb-dev libzstd-dev libaio-dev uuid-dev libpulse-dev netcat iputils-ping liblapack3 libblas-dev liblapack-dev Very important $ sudo apt update &amp;amp;&amp;amp; apt install g++ gcc gfortran git make ccache python3 python3-dev python3-pip gdb gdbserver htop tig zsh vim language-pack-en xmodmap hugo ripgrep global universal-ctags terminator $ sudo apt remove --purge -y &amp;amp;&amp;amp; sudo rm -rf /var/lib/apt/lists/* # install CMake $ wget -qO- &amp;#34;https://github.</description>
    </item>
    
    <item>
      <title>Python Type Hints</title>
      <link>https://xuanyang-cn.github.io/posts/2022/11/python-type-hints/</link>
      <pubDate>Thu, 03 Nov 2022 13:30:01 +0800</pubDate>
      
      <guid>https://xuanyang-cn.github.io/posts/2022/11/python-type-hints/</guid>
      <description>Note The Python runtime does not enforce function and variable type annotations. They can be used by third party tools such as type checkers, IDEs, linters, etc.
  Type hints help document the code Type hints improve IDEs and linters Type hints help you build and maintain a cleaner architecture.  Generics denote expected types for container elements.
from collections.abc import Sequence from typing import TypeVar T = TypeVar(&amp;#39;T&amp;#39;) # Declare type variable def first(l: Sequence[T]) -&amp;gt; T: # Generic function return l[0] Useful types in typing module typing.</description>
    </item>
    
    <item>
      <title>Clean Code 1: Names</title>
      <link>https://xuanyang-cn.github.io/posts/2022/03/clean-code-1-names/</link>
      <pubDate>Sat, 26 Mar 2022 12:35:00 +0800</pubDate>
      
      <guid>https://xuanyang-cn.github.io/posts/2022/03/clean-code-1-names/</guid>
      <description>If we all checked-in our code a little cleaner than when we checked it out, the code simply could not rot.
 Clean Code 1: Names 1. Choose your name thoughtfully. 2. Communicate your intent. Intervals! (a, b) open [a, b] closed (a, b] open left [a, b) open right 3. Avoid Disinformation. 4. Pronounceable Names.  Methods: verb Classes: noun Boolean: isEnough Enum: adjective  5. Avoid Encodings. // Avoid psz int *pszBasket 6.</description>
    </item>
    
    <item>
      <title>WiscKey 论文阅读笔记</title>
      <link>https://xuanyang-cn.github.io/posts/2022/03/wisckey-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Sat, 26 Mar 2022 12:30:00 +0800</pubDate>
      
      <guid>https://xuanyang-cn.github.io/posts/2022/03/wisckey-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</guid>
      <description>WiscKey 论文阅读笔记 WiscKey: Separating Keys from Values in SSD-conscious Storage
1. 资源 论文：
 Lanyue Lu, Thanumalayan Sankaranarayana Pillai, Andrea C. Arpaci-Dusseau, and Remzi H. Arpaci-Dusseau. 2016. WiscKey: Separating keys from values in SSD-conscious storage. In Proceedings of the 14th USENIX Conference on File and Storage Technologies (FAST’16). https://dl.acm.org/doi/pdf/10.1145/3033273 Lanyue Lu, Thanumalayan Sankaranarayana Pillai, Hariharan Gopalakrishnan, Andrea C. Arpaci- Dusseau, and Remzi H. Arpaci-Dusseau. 2017. WiscKey: Separating keys from values in SSD-conscious storage.</description>
    </item>
    
    <item>
      <title>GO Module</title>
      <link>https://xuanyang-cn.github.io/posts/2021/03/go-module/</link>
      <pubDate>Fri, 26 Mar 2021 14:52:08 +0800</pubDate>
      
      <guid>https://xuanyang-cn.github.io/posts/2021/03/go-module/</guid>
      <description>Creating a new module // hello.go package hello func Hello() string { return &amp;#34;Hello, world.&amp;#34; } // hello_test.go package hello import &amp;#34;testing&amp;#34; func TestHello(t *testing.T){ want := &amp;#34;Hello, world.&amp;#34; if got := Hello(); got != want { t.Errorf(&amp;#34;Hello() = %q, want %q, got, want&amp;#34;) } } $ go test $ go mod init example.com/hello go mod init write a go.mod file.
Adding a dependence package hello import &amp;#34;rsc.io/quote&amp;#34; func Hello() string { return quote.</description>
    </item>
    
    <item>
      <title>Go profiling tools</title>
      <link>https://xuanyang-cn.github.io/posts/2021/03/go-profiling-tools/</link>
      <pubDate>Fri, 26 Mar 2021 14:52:08 +0800</pubDate>
      
      <guid>https://xuanyang-cn.github.io/posts/2021/03/go-profiling-tools/</guid>
      <description>How to profile in Go? How to choose tools for profiling? PProf: CPU, Mem, Goroutinue Blocking, Graphics, Goroutines, Mutexes
Trace: Goroutine creation/blocking/unblocking, syscall enter/exit/block, GC-related events, changes of heap size, processor start/stop, etc.
dlv: Single step debugging
gdb: Single step debugging
Basic Usages of Tools 1. GCTRACE  gctrace: setting gctrace=1 causes the garbage collector to emit a single line to standard error at each collection, summarizing the amount of memory collected and the length of the pause.</description>
    </item>
    
    <item>
      <title>Cgo: All You Need to Know</title>
      <link>https://xuanyang-cn.github.io/posts/2021/02/cgo-all-you-need-to-know/</link>
      <pubDate>Tue, 23 Feb 2021 16:05:20 +0800</pubDate>
      
      <guid>https://xuanyang-cn.github.io/posts/2021/02/cgo-all-you-need-to-know/</guid>
      <description>Cgo Intro Cgo 让 GO 可以调用 C 的代码。
接下来就用一个简单的例子来介绍 Cgo 的用法。
下面 GO 的 rand 包提供了两个方法 Random 和 Seed， 它们分别调用了 C 的 random 和 srandom 方法。
package rand /* #include &amp;lt;stdlib.h&amp;gt; */ import &amp;#34;C&amp;#34; func Random() int { return int(C.random()) } func Seed(i int) { C.srandom(C.uint(i)) } // ref@https://blog.golang.org/cgo 从 import 语句来看，rand 包引入了 &amp;quot;C&amp;quot;， 但是你会发现标准 Go library 里并没有 C 这个库。这是因为 C 是一个伪包 (pesudo-package)，是一个可以被 cgo 解析的特殊名字，用来确定代码里 C 的命名空间。
rand 包用到 C 的地方有 4 个：C.</description>
    </item>
    
    <item>
      <title>Delve Hand Book</title>
      <link>https://xuanyang-cn.github.io/posts/2021/02/delve-hand-book/</link>
      <pubDate>Thu, 18 Feb 2021 15:34:42 +0800</pubDate>
      
      <guid>https://xuanyang-cn.github.io/posts/2021/02/delve-hand-book/</guid>
      <description>Launch a session dlv debug works like go run, it will build an run a GO package
dlv exec will start a seesion with a precompiled binary, in order to properly debug a binary, it shoud be compiled with optimizations disablesd, eg. with -gcflags=&amp;quot;all=-N -l&amp;quot;
dlv attach will attach to a PID of a runnig Go binary
Delve commands in a debugging session print, p
whatis will print the datatype of an expression</description>
    </item>
    
    <item>
      <title></title>
      <link>https://xuanyang-cn.github.io/about/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://xuanyang-cn.github.io/about/</guid>
      <description>#include &amp;lt;iostream&amp;gt; int main() { std::cout &amp;lt;&amp;lt; &amp;#34;Nothing is perfect, &amp;#34; &amp;lt;&amp;lt; &amp;#34;we&amp;#39;re just running out of time.&amp;#34; &amp;lt;&amp;lt; std::endl; return 0; } What to do next?     Article Categories Draft     My vim configs vim Y    </description>
    </item>
    
  </channel>
</rss>
